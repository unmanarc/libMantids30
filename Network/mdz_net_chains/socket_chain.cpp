#include "socket_chain.h"
#include <thread>

using namespace Mantids::Network::Sockets;

Socket_Chain::Socket_Chain(Mantids::Network::Sockets::Socket_StreamBase *_baseSocket, bool _deleteBaseSocketOnExit)
{
    endPointReached = false;
    deleteBaseSocketOnExit = _deleteBaseSocketOnExit;
    baseSocket = _baseSocket;
}


void Socket_Chain::waitUntilFinish()
{
    for (sChainVectorItem * sockItem : socketLayers)
    {
        if (!sockItem->detached)
        {
            sockItem->thr1.join();
            sockItem->thr2.join();

            sockItem->detached = true;
            sockItem->finished = true;
        }
    }
}

void Socket_Chain::removeSocketsOnExit()
{
    for (sChainVectorItem * sockItem : socketLayers)
    {
        if (sockItem->deleteFirstSocketOnExit)
        {
            delete sockItem->sock[0];
            sockItem->sock[0] = nullptr;
        }
        if (sockItem->deleteSecondSocketOnExit)
        {
            delete sockItem->sock[1];
            sockItem->sock[1] = nullptr;
        }
    }
}

Socket_Chain::~Socket_Chain()
{
    // Propagate the shutdownSocket
    Socket_Chain::shutdownSocket();

    // Wait for threads:
    waitUntilFinish();

    // Delete if needed.
    removeSocketsOnExit();

    // Remove items when all threads are down.
    for (sChainVectorItem * sockItem : socketLayers)
    {
        delete sockItem;
    }
    socketLayers.clear();

    // delete the base socket if needed.
    if (deleteBaseSocketOnExit) delete baseSocket;
}


size_t Socket_Chain::getLayers()
{
    return socketLayers.size();
}

int Socket_Chain::getLayerReadResultValue(size_t layer, bool fwd)
{
    if (layer>=socketLayers.size()) return -2;
    // TODO: check this.
    return ((sChainVectorItem *)socketLayers[layer])->r0[fwd?0:1];
}

bool Socket_Chain::getLayerWriteResultValue(size_t layer, bool fwd)
{
    if (layer>=socketLayers.size()) return false;
    // TODO: check this.
    return ((sChainVectorItem *)socketLayers[layer])->w1[fwd?0:1];
}

std::pair<Mantids::Network::Sockets::Socket_StreamBase *, Mantids::Network::Sockets::Socket_StreamBase *> Socket_Chain::getSocketPairLayer(size_t layer)
{
    std::pair <Mantids::Network::Sockets::Socket_StreamBase *, Mantids::Network::Sockets::Socket_StreamBase *> bar;

    if (layer>=socketLayers.size())
        return std::make_pair (nullptr,nullptr);

    return std::make_pair (((sChainVectorItem *)socketLayers[layer])->sock[0],((sChainVectorItem *)socketLayers[layer])->sock[1]);
}


bool Socket_Chain::addToChain(ChainProtocols::Socket_Chain_ProtocolBase *chainElement, bool deleteAtExit)
{
    return addToChain( chainElement->makeSocketChainPair(),
                             deleteAtExit, // If it's not a  detached pointer, declare as false, if it's detached true (when Socket_Chain die, then, this chain element will die too)
                             true, // Second socket is generated by makeSocketChainPair, should be automatically deleted here.
                             chainElement->isServerMode(), // Server mode: true
                             false, // Detached is false (should wait until finalization when deleting Socket_Chain...)
                             chainElement->isEndPoint()
                             );
}

bool Socket_Chain::addToChain(std::pair<Mantids::Network::Sockets::Socket_StreamBase *, Mantids::Network::Sockets::Socket_StreamBase *> sockPairs, bool deleteFirstSocketOnExit, bool deleteSecondSocketOnExit, bool modeServer, bool detached, bool endPMode)
{
    if (endPointReached) return false;
    if (endPMode) endPointReached = true;

    sChainVectorItem * item = new sChainVectorItem;

    // Register on chain
    item->deleteFirstSocketOnExit = deleteFirstSocketOnExit;
    item->deleteSecondSocketOnExit = deleteSecondSocketOnExit;
    item->sock[0] = sockPairs.first;
    item->sock[1] = sockPairs.second;
    item->modeServer = modeServer;
    socketLayers.push_back(item);

    // Register on thread.
    sChainTElement * chainTElem1 = new sChainTElement;
    sChainTElement * chainTElem2 = new sChainTElement;

    chainTElem1->sockets[0] = item->sock[1];
    chainTElem1->sockets[1] = socketLayers.size()==1? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-2])->sock[0];
    chainTElem1->modeFWD = true;
    chainTElem1->r0 = &(item->r0[0]);
    chainTElem1->w1 = &(item->w1[0]);

    chainTElem2->sockets[0] = chainTElem1->sockets[1];
    chainTElem2->sockets[1] = chainTElem1->sockets[0];
    chainTElem2->modeFWD = false;
    chainTElem2->r0 = &(item->r0[1]);
    chainTElem2->w1 = &(item->w1[1]);

    item->thr1 = std::thread(chainThread, chainTElem1);
    item->thr2 = std::thread(chainThread, chainTElem2);

    if (detached)
    {
        item->detached = true;
        item->thr1.detach();
        item->thr2.detach();
    }

    ///////////////////////////////////
    // Now we init this socket...
    bool r;
    if (modeServer)
        r = sockPairs.first->postAcceptSubInitialization();
    else
        r = sockPairs.first->postConnectSubInitialization();

    if (!r)
    {
        item->sock[0]->shutdownSocket();
        item->sock[1]->shutdownSocket();
    }

    return r;
}

bool Socket_Chain::isConnected()
{
    if (socketLayers.size() == 0 && !baseSocket) return false;
    Mantids::Network::Sockets::Socket_StreamBase * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    return curSocket->isConnected() && baseSocket->isConnected();
}

int Socket_Chain::shutdownSocket(int mode)
{
    if (socketLayers.size() == 0 && !baseSocket) return -1;
    Mantids::Network::Sockets::Socket_StreamBase * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    return curSocket->shutdownSocket(mode);
}

int Socket_Chain::partialRead(void *data, const uint32_t & datalen)
{
    if (socketLayers.size() == 0 && !baseSocket) return -1;
    Mantids::Network::Sockets::Socket_StreamBase * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    int x = curSocket->partialRead(data,datalen);
    if (x<=0)
        return x;
    return x;
}

int Socket_Chain::partialWrite(const void *data, const uint32_t &datalen)
{
    if (socketLayers.size() == 0 && !baseSocket) return -1;
    Mantids::Network::Sockets::Socket_StreamBase * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    int x = curSocket->partialWrite(data,datalen);
    if (x<=0)
        return x;
    return x;
}

void Socket_Chain::chainThread(sChainTElement *chain)
{
    char data[4096];
    int r0;
    bool w1=0;

    while (     (r0=chain->sockets[0]->partialRead(data,sizeof(data)))>0 &&
                ((w1=chain->sockets[1]->writeFull(data,r0)))==true )
    {
    }

    // Write result values
    *(chain->r0) = r0;
    *(chain->w1) = w1;

    // TODO: call ending phase functions for stream sockets...

    // Shutdown sockets...
    chain->sockets[0]->shutdownSocket(SHUT_RD);
    chain->sockets[1]->shutdownSocket(SHUT_WR);

    delete chain;
}
